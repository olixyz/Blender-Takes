# import bpy
from bpy import context

def _traverse_tree(t):
    """
    recursively walk the viewLayer collection hierarchy.
    Solution by batFINGER:
    https://blender.stackexchange.com/questions/137860/disable-render-of-all-collections-with-python-in-blender-2-8/137866#137866
    """
    yield t
    for child in t.children:
        yield from _traverse_tree(child)

# Setup scene and viewlayer for take
def setup_take(scenename="Scene", viewlayername="ViewLayer"):
    """ Setup Scene and ViewLayer. 
    
    Sets all objects to visible and renderable 
    (render visibility is handled per collection, not per object!).

    Keep only specified scene and create a new viewLayer (this resets all settings).
    
    """
    def _all_visible(scenename="Scene", viewlayername="ViewLayer"):
        # Turn all objects on for rendering
        for o in bpy.data.objects:
            o.hide_viewport = False
            o.hide_render = False
            
            # Handle object visibility in viewLayer    
            vl_o = bpy.data.scenes[scenename].view_layers[viewlayername].objects.get(o.name)
            if hasattr(vl_o, "hide_set"):
                vl_o.hide_set(0)
    
    # The name 'take' is reserved for the viewLayer 
    # generated by the script. Therefore check if a viewLayer named 'take'
    # exists.
    for s in bpy.data.scenes:
        if s.view_layers.get("take"):
            raise Exception("A viewLayer must not be called 'take'. Please rename")

    # Catch if scenename and viewLayer do not exist
    if not bpy.data.scenes.get(scenename):
        raise Exception("Scene '{}' not in file".format(scenename))
                
    if not bpy.data.scenes[scenename].view_layers.get(viewlayername):
        raise Exception("ViewLayer '{}' not in Scene".format(viewlayername))
    
    # Loop over all viewLayer and delete if it is 
    # not the one specified by the user
    for vl in bpy.data.scenes[scenename].view_layers:
        if vl.name != viewlayername:
            bpy.data.scenes[scenename].view_layers.remove(vl)

    # Loop over scenes and delete if it is
    # not the one specified by the user
    for s in bpy.data.scenes:
        if s.name != scenename:
            bpy.data.scenes.remove(s)
          
    # Create a new ViewLayer so we have clean ViewLayer settings.
    bpy.context.scene.view_layers.new("take")
    
    # Delete the original viewLayer
    vl = bpy.data.scenes[scenename].view_layers[viewlayername]
    bpy.data.scenes[scenename].view_layers.remove(vl)  
    
    _all_visible(scenename, "take")


def hide_all():
    """ Hide all collections in render.
    """
    coll = bpy.data.collections
    for c in coll:
        c.hide_render = True
        c.hide_viewport = True


def show(c_list):
    """ Make list of collections visible in render. 
    
    Does not handle parent collection visibility.
    """
    # coll = bpy.data.collections
    coll = bpy.context.view_layer.layer_collection
    
    for c in _traverse_tree(coll):
        if c.name in c_list:
            c.hide_viewport = False

    for x in c_list:
            bpy.data.collections[x].hide_render = False
            bpy.data.collections[x].hide_viewport = False

def world(world_name):
    """ Set world by name.
    """
    bpy.context.scene.world = bpy.data.worlds[world_name]


def clear_materials(c_list):
    """ Clear all material slots of objects in collections.
    """
    coll = bpy.data.collections
    for coll in c_list:
        for o in bpy.data.collections[coll].objects:
            if o.type == "MESH":
                o.data.materials.clear()



def not_visible_to_camera(c_list):
    """ Set objects in specified collections to not visible to camera.
    """
    for coll in c_list:
        for o in bpy.data.collections[coll].objects:
            if o.type == "MESH":
                o.visible_camera = False


def holdout(c_list):
    """ Set objects in specified collections to holdout.
    """
    for coll in c_list:
        for o in bpy.data.collections[coll].objects:
            if hasattr(o, "is_holdout"):
            #if o.type == "MESH":
                o.is_holdout = True


def overscan(o_fac):
    """ Overscan the camera.
    Use a multiplier, e.g. 1.1, 1.2
    """
    res_x = bpy.context.scene.render.resolution_x
    res_y = bpy.context.scene.render.resolution_y
    bpy.context.scene.render.resolution_x = int(res_x * o_fac)
    bpy.context.scene.render.resolution_y = int(res_y * o_fac)

    cam = bpy.context.scene.camera
    cam.data.sensor_width *= o_fac


def set_range(in_marker, out_marker):
    """ Set timeline range from in and out marker.
    """
    marker_in = context.scene.timeline_markers.get(in_marker)
    marker_out = context.scene.timeline_markers.get(out_marker)
    bpy.context.scene.frame_start = marker_in.frame
    bpy.context.scene.frame_end = marker_out.frame


def all_mat_override(mat_name):
    """ Material override on all objects
    """
    material = bpy.data.materials[mat_name]

    for o in list(bpy.data.objects):
        if o.type == "MESH":
            o.data.materials.clear()
            o.data.materials.append(material)
            # o.data.materials[0]=material


def collection_mat_override(c_list, mat_name):
    """ Material override on objects in collections
    """
    material = bpy.data.materials[mat_name]
    for coll in c_list:
        for o in bpy.data.collections[coll].objects:
            if o.type == "MESH":
                o.data.materials.clear()
                o.data.materials.append(material)


def remove_collections(c_list):
    """ Remove collection and all its children from file.
    """
    for coll in c_list:
        if coll in bpy.data.collections:

            my_col = bpy.data.collections[coll]

            while my_col.objects:
                bpy.data.objects.remove(my_col.objects[0], do_unlink=True)

            bpy.data.collections.remove(my_col, do_unlink=True)

def add_lightgroups(lgs):
    """ Add array of lightgroup names 
    """
    for lg in lgs:
        # if lightgroup already in list, do not add
        lgroup = bpy.context.view_layer.lightgroups.get(lg)
        if not lgroup:
            bpy.context.view_layer.lightgroups.add(name=lg)

def add_aovs_color(aovs):
   """ Add array of color aovs 
    """
   for aov in aovs:
        aov_to_add = bpy.context.view_layer.aovs.get(aov)
        if not aov_to_add:
            a = bpy.context.view_layer.aovs.add()
            a.name = aov
            a.type = "COLOR"

def add_aovs_value(aovs):
   """ Add array of value aovs 
   """
   for aov in aovs:
        aov_to_add = bpy.context.view_layer.aovs.get(aov)
        if not aov_to_add:
            a = bpy.context.view_layer.aovs.add()
            a.name = aov
            a.type = "VALUE"
